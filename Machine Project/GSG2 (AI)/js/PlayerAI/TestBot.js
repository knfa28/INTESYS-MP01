// Global variables!
var currentMove;    // current index of movement direction
var hasMoved;                   // checks whether you have already moved
var path;                  // list containing movements that were path
var move;   // current move of the player
var enemyArea; //current area occupied by the enemies on the map
var hazards; //all current hazards on the map as generated by function genHazards(); used in isHazardous();
var direct = [[0,-1],[0,1],[-1,0],[1,0]];  //Essentially, north, south, east, west
var cur; //current player position
var prev;  //previous player position
var next;   //next player position
var enemyPos;           //positions of all enemy bots
var go;	// integer variable that determines the start of our AI's movement
var delay;  // delay at start of game to allow enemy bots to initialize their movement first
var done; // if thinking is finished
var process; // the current decision of the bot
var j = 0; // variable for for loops that are used across different functions
var waypoints; //enemy waypoints
var spotted = 0; // is the bot still stealthy?
var k = 1; // variable for for loops that are used across different functions
var processdelay = 0; // delay to allow our AI to think more openly and avoid crashing into enemies

//"main" functions, or at least the equivalents of "main" in C; this is where the magic happens.
//all the other functions in this js are used by this function, or by other functions within this js
//that need it.
function TestBot(){
	this.loaded = true;
	this.Name="PlayerAI";

	//every other .33s this function is called to allow the AI at current position to decide where to go
	//after its current location. it checks for the enemy locations and their FOVs, and will actively
	//avoid all of them on its way to an end that is not walled off
	this.thinkAI= function(player, enemies, maplayout, end) {
		if(process>processdelay){ //Original 50
			if(go>delay){
				if(done){
					enemyArea = getEnemyArea(enemies, enemyArea);
					hazards=genHazards(enemies, enemyArea);
					this.Thinking(player, enemies, maplayout, end);
					go/=k;
				}
			}
			else
				go++;
		}
		else{
				enemyArea = getEnemyArea(enemies, enemyArea);
				process++
				//Test - does longer processing mean smarter AI? Does shorter affect it negatively?
				//Lower number seems to make the bot dumber...
		}
	}
	
	//start of every level. a delay is implemented so that the bot doesn't crash into an enemy that has
	//not moved/gotten initialized yet. the delay is done so that before the AI moves, it knows the enemy
	//locations as well as their sight lines.
	this.initAI = function(player, enemies, maplayout, end) {
		go=0;
		j=0;
		delay = 4; //As the name implies, creates a delay. 
		process=0;
		processdelay = 0;
		done = false;
		enemyArea=new Array(enemies.length);
		for(var i=0; i<enemyArea.length; i++)
			enemyArea[i]=new Array();
		cur=[player.getX(), player.getY()];
		prev = [-1,-1];
		hasMoved = true;
		currentMove=0;
	}
	
	//this is an optional function to be filled; it is called when the AI gets to the end goal, right
	//before the next map loads. theoretically this can be used to augment the AI's knowledge everytime
	//it finishes a level. (hey i finished this in 3 times; where did i go wrong and how do i go about
	//avoiding making the same mistakes on the next level, given similar circumstances?)
	this.endAI = function(){

	}

	//this function is called every time the AI gets spotted; right before the user reboots the map.
	//this is used for the AI to adapt and learn and avoid making the same mistake on the next try.
	//we used this to avoid going into the same end goal (given many end goals) if we get caught on the
	//way there too many times.
	this.spottedAI = function(){
		process = 0;
		processdelay += 70; //so that on the next try the AI gets more time to think about its path
		//delay +=4;
		//k+=1;
		if(waypoints.length != 1 && waypoints.length != null)
			j++;
	}

	//this function is used for the AI to think about its next move. and then acts upon that decision.
	//1. if the end goal exists, get the heuristics of the tiles from the current position to the goal;
	//2. based on the heuristics, find the most efficient path;
	//3. if the end goal does not exist, look for another end goal and do 1 and 2 again;
	//4. so the best path is laid out and the bot is moving. but along every tile on the path, 
	//	it checks if it is hazardous
	//	(if there are enemies there or enemy sight lines or possible enemy patrol routes)
	//	and finds a path around that tile accordingly, so that it doesn't get caught
	this.Thinking=function(player, enemies, maplayout, end){
		var q = -1;
		waypoints = end;
        cur = [player.getX(), player.getY()];
        if ((cur[0]!=prev[0]||cur[1]!=prev[1])){
				
        	do{
        		
        		if(end[q + j] != null || q + j < 0)
        		q++;
				var h = computeH(cur,[end[q + j].getX(), end[q + j].getY()]);
				var n = new tile(cur, [-1, -1], h, 0, h);
				path = pathFind(n, [end[q + j].getX(), end[q + j].getY()], maplayout, enemies);
			}while(pathFind(n, [end[q + j].getX(), end[q + j].getY()], maplayout, enemies) == null);
                move = path[currentMove];
				
				next = [cur[0]+direct[move][0], cur[1]+direct[move][1]];
				if(isHazardous(next, enemies)){
					for(var i=0; i<direct.length; i++){
						next = [cur[0]+direct[i][0], cur[1]+direct[i][1]];
						if(!isHazardous(next,enemies)&&maplayout[next[0]][next[1]]!=3){
							move = i;
							break;
						}
					}
				}
				switch(move){ // do your decided move
					case 0: hasMoved = player.MoveUp(); 
							break;
					case 1: hasMoved = player.MoveDown(); 
							break;
					case 2: hasMoved = player.MoveLeft(); 
							break;
					case 3: hasMoved = player.MoveRight(); 
							break;
        		}
				prev = cur;
				
        }
    }




}

// given all the enemies in an area, mark all the spots that these enemies and their sight lines occupy.
// return all those spots.
function getEnemyArea(enemies, area){
	var eLight; //Enemies viewpoint
	var list;
	var temp;
	var x, y, f;
	done = true;
	for(var i=0; i<enemies.length; i++){
		
		x = enemies[i].getX();
		y = enemies[i].getY() ;
		f = enemies[i].getFacing();
		if(!inArea(area[i],[x, y, f])){
			
			eLight = new Array();
			temp = new Array();
			eLight.push([x,y]);
			eLight.push(f);
			list = enemies[i].Light.ListofArray;
			for(var j=0; j<list.length; j++)
				temp.push([list[j].x, list[j].y]);
			eLight.push(temp);
			area[i].push(eLight);
		}
		
	}
	return area;
}

// used by getEnemyArea
// used to distinguish discrete enemies from the areas that each of them occupy
function inArea(area, place){
	var cur, f;
	for(var i=0; i<area.length; i++){
		cur = area[i][0];
		f = area[i][1];
		if(cur[0]==place[0]&&cur[1]==place[1]&&f==place[2])
			return true;
	}
	return false;
}

//	used in pathFind
//	heuristics used in pathfinding with A* search algorithm
function tile(coord, parent, h, g, f){
	this.coord=coord;
	this.parent=parent;
	this.h=h;
	this.g=g;
	this.f=f;
	
	this.getCoord = function(){
		return this.coord;
	}
	
	this.getParent = function(){
		return this.parent;
	}
	
	this.getH = function(){
		return this.h;
	}
	
	this.getG = function(){
		return this.g;
	}
	
	this.getF = function(){
		return this.f;
	}
	
	this.setParent = function(newP){
		this.parent=newP;
	}
	
	this.setH = function(newH){
		this.h=newH;
	}
	
	this.setG = function(newG){
		this.g=newG;
	}
	
	this.setF = function(newF){
		this.f=newF;
	}
}

// generate all spots that the AI should avoid in order to not get spotted
// basically get the enemy areas and predict where they'll go next, and avoid those spots.
function genHazards(enemies, enemyArea){
	var enemy;
	var area;
	var loc;
	var hazards=new Array();
	enemyPos = new Array();
	for(var h=0; h<enemies.length; h++){
		enemy=[enemies[h].getX(),enemies[h].getY(),enemies[h].getFacing()];
		for(var i=0; i<enemyArea.length;i++){
			area=enemyArea[i];
			for(var j=0; j<area.length; j++){
				loc=area[j][0];
				if(loc[0]==enemy[0]&&loc[1]==enemy[1]&&area[j][1]==enemy[2]){
					enemyPos.push(j);
					hazards.push(area[(j)%area.length][2]);
					hazards.push(area[(j+1)%area.length][2]);
					break;
				}
			}
		}
	}
	return hazards;
}

// heuristic function that resembles the one used in greedy best first search
function computeG(parent, child, enemies){
	if(isHazardous(child, enemies))
		return parent.getG()+1000;
	else
		return parent.getG()+10;
}

// another heuristic function used in pathfinding
function computeH(point, end){
	return (Math.abs(point[0]-end[0])+Math.abs(point[1]-end[1]))*10;
}

// a heuristic function that is used in A* (combination of g and h)
function computeF(g, h){
	return g+h;
}

// sorts an array in ascending order  
function arrange(open){
	var temp;
	
	for(var i=0; i<open.length-1; i++){
		for(var j=open.length-1; j>i; j--){
			if(open[i].getF()>open[j].getF()){
				temp = open[j];
				open[j] = open[i];
				open[i] = temp;
			}
		}
	}
	
	return open;
}

//checks if a point is in the array "closed"
function inClosed(point, closed){
	var cur;
	for(var i=0; i<closed.length; i++){
		cur = closed[i].getCoord();
		if(cur[0]==point[0]&&cur[1]==point[1])
			return true;
	}
	return false;
}

//checks if a point is in the array "open"
function inOpen(point, open){
	var cur;
	for(var i=0; i<open.length; i++){
		cur = open[i].getCoord();
		if(cur[0]==point[0]&&cur[1]==point[1])
			return true;
	}
	return false;
}

// check the change in state from a certain point to the next
function checkChange(parent, point, g, open){
	var cur;
	for(var i=0; i<open.length; i++){
		cur = open[i].getCoord();
		if(cur[0]==point[0]&&cur[1]==point[1])
			if(g<open[i].getG()){
				open[i].setParent(parent);
				open[i].setG(g);
				open[i].setF(open[i].getH()+open[i].getG());
				break;
			}
	}
	return open;
}

// returns the reverse of a path
function reverse(path){
	var rPath = new Array();
	for(var i=path.length-1; i>=0; i--)
		rPath.push(path[i]);
	
	return rPath;
}

// does the area have enemies or hazards?
function isHazardous(player, enemies){
	var pX=player[0];
	var pY=player[1];
	var area;
	/*Below for loop code determines how many hazards there are in the present instance of the map
	 *If a certain hazard is d
	 *
	 *'hazards.length' is essentially how many hazards there are in the map.
	 *hazards[i] depicts an array of hazards holding there current positions. Area holds the current instance of the hazard
	 *
	 */
	for(var q = 0; q < enemies.length; q++){
	if(enemies[q].getX() == player[0] && enemies[q].getY() == player[1])
		return true;
}
	for(var i=0; i<hazards.length; i++){
		area=hazards[i];
		for(var j=0; j<area.length; j++){
			if(area[j][0]==pX&&area[j][1]==pY)
				return true;
		}
	}
	return false;

}

// this function will generate a possible path from start to end and returns the reverse of it
// used in pathFind()
function genPath(closed, start, end){
	var cur=end;
	var prev;
	var done=false;
	var i;
	var path = new Array();
	while(!done){
		for(i=0; i<closed.length; i++){
			prev=closed[i].getCoord();
			if(cur[0]==prev[0]&&cur[1]==prev[1])
				break;
		}
		if(closed[i] == undefined)
			return null;
		prev=closed[i].getParent();
		if(cur[0]<prev[0])
			path.push(2);		
		else if(cur[0]>prev[0])
			path.push(3);
		else if(cur[1]<prev[1])
			path.push(0);
		else if(cur[1]>prev[1])
			path.push(1);
		
		cur = prev;
		if(cur[0]==start[0]&&cur[1]==start[1])
				done=true;
	}
	return reverse(path);
}

// this is the pathfinder function. it takes into account all enemies along the path
// return a generated path from the starting point to the end
function pathFind(start, end, maplayout, enemies){
	var open = new Array();
	var closed = new Array();
	var connected = new Array();
	var found = false;
	var curPos;
	var next;
	var h, g;
	var count=0;
	open.push(start);
	
	while(!found&&open.length>0){
		open = arrange(open);
		curPos = open[0].getCoord();
		
		for(var i=0; i<direct.length; i++){
			next=new Array();
			next.push(curPos[0]+direct[i][0]);
			next.push(curPos[1]+direct[i][1]);
			h = computeH(next, end);
			g = computeG(open[0], next, enemies);
			
			if(next[0]<0||next[1]<0||next[0]>=20||next[1]>=20){}
			else if(maplayout[next[0]][next[1]]==3||inClosed(next,closed)){}
			else if(inOpen(next, open)){
				open = checkChange(curPos, next, g, open);
			}
			else{
				open.push(new tile(next, curPos, h, g, g+h));
			}
			if(next[0]==end[0]&&next[1]==end[1]){
				closed.push(open[open.length-1]);
				open.splice(open.length-1,1);
				found = true;
				break;
			}

		}	
		closed.push(open[0]);
		open.splice(0, 1);
	}
	return genPath(closed, start.getCoord(), end);
}

// Other functions 

// this function generates a random number based on a min and a max
//ex. random(5,100) returns a random number from 5 to 100
function random(start,end)
{
    return Math.floor((Math.random()*end)+start);
}